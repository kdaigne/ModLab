%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%
%%                               importBodies                            %%
%%                         Last update: July 31, 2024                    %%
%%                               KÃ©vin Daigne                            %%
%%                         kevin.daigne@hotmail.fr                       %%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%
% Summary: imports/Deletes bodies from an other simulation

% #. Mode
input.mode=questdlg('What type of change is requested concerning the bodies?','Type','Import','Delete','Cancel','Cancel');
figure(app.mainUIFigure);
if isempty(input.mode) || strcmpi(input.mode,'Cancel')
    return;
end

% #. Import
tabNumberImport=findTab(app);
refreshSteps(app,tabNumberImport,1);
input.stepImport=app.TabGroup.Children(tabNumberImport).Children(app.id.gridTabNumber).Children(app.id.gridProcessingNumber).Children(app.id.STEPSPanelNumber).Children(app.id.gridStepsNumber).Children(app.id.stepsListNumber).Items{1}; % Last step
input.bodyNumberImport=numel(app.TabGroup.Children(tabNumberImport).Children(app.id.gridTabNumber).Children(app.id.gridProcessingNumber).Children(app.id.EDITORPanelNumber).Children(app.id.gridControlNumber).Children(app.id.sectionsListButtonNumber).Items(2:end)); % Number of bodies

if strcmpi(input.mode,'Import')

    % #. Tab selection
    % #.#. Pre-processing
    tabList=cell(1,numel(app.TabGroup.Children)-2);
    for tabNumberVar=3:numel(app.TabGroup.Children)
        tabList{tabNumberVar-2}=app.TabGroup.Children(tabNumberVar).Title;
    end
    % #.#. DLG
    [indTab,~]=listdlg('Name','Tab','PromptString',{'Select the tab that contains' 'the bodies to be imported:'},'listString',tabList,'SelectionMode','single','InitialValue',tabNumberImport-2);
    figure(app.mainUIFigure);
    if isempty(indTab)
        return;
    end
    % #.#. Output
    tabNumberExport=indTab+2; % Tab index where the data are exported

    % #. Step selection
    % #.#. Pre-processing
    stepListExport=loadListStep(app,tabNumberExport);
    if isempty(stepListExport)
        msgbox('No steps can be found in this tab.','Information','help'); return;
    end
    % #.#. DLG
    [indStep,~] = listdlg('Name','Step','PromptString',{'Select the step that contains' 'the data to be imported:'},'listString',stepListExport,'SelectionMode','single','InitialValue',1);
    figure(app.mainUIFigure);
    if isempty(indStep)
        return;
    end
    % #.#. Output
    input.stepExport=stepListExport{indStep}; % Step for which the data are exported

    % #. Body selection
    % #.#. DLG
    input.bodiesToExport=bodiesSelection(app,tabNumberExport,[],input.stepExport);
    if isempty(input.bodiesToExport)
        return;
    end
    % #.#. Outputs
    input.bodiesToExport=strsplit(input.bodiesToExport); % List of the bodies to be exported
    input.bodiesToExportNumber=numel(input.bodiesToExport); % Number of bodies to be exported

    % #. Location selection
    % #.#. Pre-processing
    locationListToCopy=['At the beginning' app.TabGroup.Children(tabNumberImport).Children(app.id.gridTabNumber).Children(app.id.gridProcessingNumber).Children(app.id.EDITORPanelNumber).Children(app.id.gridControlNumber).Children(app.id.sectionsListButtonNumber).Items(2:end)];
    % #.#. DLG
    [indBody,~] = listdlg('Name','Location','PromptString',{'Bodies will be added just after' 'the selected body:'},'listString',locationListToCopy,'SelectionMode','single','InitialValue',1);
    figure(app.mainUIFigure);
    if isempty(indBody)
        return;
    end
    % #.#. Outputs
    input.bodyBefore=indBody-2; % -1 because the body indexation starts from 0 and -1 because the bodies start from the 2nd proposal
    if indBody==1
        input.assignInput='addBefore'; % Will be added before the first body
    else
        input.assignInput='addAfter'; % Will be added after the selected body
    end

    % #. Shift
    % #.#. DLG
    prompt={'X shift (x desired - x current):','Y shift (y desired - y current):'}; dlgtitle='Shift'; dims=[1 35]; definput={'0','0'};
    answer=inputdlg(prompt,dlgtitle,dims,definput);
    figure(app.mainUIFigure);
    if isempty(answer)
        return;
    end
    % #.#. Outputs
    input.xShift=str2double(answer{1}); input.yShift=str2double(answer{2});
    if isnan(input.xShift) || isnan(input.yShift)
        msgbox('Unknown format.','Information','help'); return;
    end

elseif strcmpi(input.mode,'Delete')

    % #. Body selection
    % #.#. DLG
    input.bodiesToExport=bodiesSelection(app,tabNumberImport,[],[]);
    if isempty(input.bodiesToExport)
        return;
    end
    % #.#. Outputs
    input.bodiesToExport=strsplit(input.bodiesToExport);
    input.bodiesToExportNumber=numel(input.bodiesToExport);

    % #. Location selection
    input.assignInput='delete';

end

% #. Paths
input.pathSimuImport=app.TabGroup.Children(tabNumberImport).Children(app.id.gridTabNumber).Children(app.id.gridProcessingNumber).Children(app.id.SAVEPanelNumber).Children(app.id.gridSaveNumber).Children(app.id.displayPathNumber).Value;
if strcmpi(input.mode,'Import')
    input.pathSimuExport=app.TabGroup.Children(tabNumberExport).Children(app.id.gridTabNumber).Children(app.id.gridProcessingNumber).Children(app.id.SAVEPanelNumber).Children(app.id.gridSaveNumber).Children(app.id.displayPathNumber).Value;
end

% #. Change
output=GUIManager('manageBodies',input);

if ~output.error

    % #. Log
    if strcmpi(input.mode,'Import')

        % #.#. Import

        logMsg={['Added on step ' input.stepImport];...
            ['Imported bodies (old indexing): ' strjoin(input.bodiesToExport)];...
            ['Imported bodies (new indexing): ' strjoin(cellfun(@num2str,num2cell(input.bodyBefore+1:input.bodyBefore+numel(input.bodiesToExport)),'UniformOutput',false))];...
            ['Shift (X,Y): [' num2str(input.xShift) ',' num2str(input.yShift) ']']};
        LogSave(logMsg,{''},'Bodies import',[input.pathSimuImport filesep 'SAVE' filesep 'LOG_save.log']);

    elseif strcmpi(input.mode,'Delete')

        % #.#. Delete

        logMsg={['Deleted on step: ' input.stepImport]; ...
            ['Deleted bodies: ' strjoin(input.bodiesToExport)]};
        LogSave(logMsg,{''},'Bodies deletion',[input.pathSimuImport filesep 'SAVE' filesep 'LOG_save.log']);

    end

    % #. Load
    loadPathFunction(app,tabNumberImport); % To refresh the GUI

end

function manageBodiesFunction(pathSimuImport,pathSimuExport,stepImport,stepExport,bodyBefore,bodiesToExport,bodyNumberImport,bodiesToExportNumber,mode,assignInput,xShift,yShift)

%% Imports or deletes bodies

% #. Paths
output.error=0;
pathControlImport=[input.pathSimuImport filesep 'CODE' filesep 'STATIC_CONTROL.asc'];
pathDataImport=[input.pathSimuImport filesep 'CODE' filesep 'STATIC_DATA.asc'];
pathDynImport=[input.pathSimuImport filesep 'CODE' filesep 'DYNAMIC_' input.stepImport '.asc'];
if strcmp(input.mode,'Import')
    pathControlExport=[input.pathSimuExport filesep 'CODE' filesep 'STATIC_CONTROL.asc'];
    pathDataExport=[input.pathSimuExport filesep 'CODE' filesep 'STATIC_DATA.asc'];
    pathDynExport=[input.pathSimuExport filesep 'CODE' filesep 'DYNAMIC_' input.stepExport '.asc'];
elseif strcmp(input.mode,'Delete')
    pathControlExport=pathControlImport;
    pathDataExport=pathDataImport;
    pathDynExport=pathDynImport;
end

% #. msg
answer = questdlg('The operation can be quite long and cannot be stopped without affecting the files, do you want to continue?', ...
    'Preview', ...
    'Yes (with backup)','Yes (without backup)','No','No');
if strcmp(answer,'No')==1 || isempty(answer)
    output.error=1;
    return;
end
if strcmp(answer,'Yes (with backup)')
    filename=[input.pathSimuImport filesep 'Backup_' replace(datestr(datetime('now')),{'[',' ','!','"','#','$','%','&','(',')','*','+',',','-','.','/',':',';','<','=','>','?','@','\','^','_','`','''','{','|','}','~',']'},'_')];
    if exist(filename,'dir')
        msgbox('Cannot save the backup because the name already exists.','Information','help');
        output.error=1;
        return;
    end
    mkdir(filename);
    copyfile(pathControlImport,filename);
    copyfile(pathDynImport,filename);
    copyfile(pathDataImport,filename);
    [~,control1,control2]=fileparts(pathControlImport);
    [~,dyn1,dyn2]=fileparts(pathDynImport);
    [~,data1,data2]=fileparts(pathDataImport);
    if ~isfile([filename filesep control1 control2]) || ~isfile([filename filesep dyn1 dyn2]) || ~isfile([filename filesep data1 data2])
        msgbox('Cannot save the backup files for an unknown reason.','Information','help');
        output.error=1;
        return;
    end
end

% #. Options pour la lecture
if strcmp(input.mode,'Import')

    % #.#. STATIC CONTOL + DYNAMIC
    optsControl=struct();
    optsControl.TypeOpen=cell(1,2*input.bodiesToExportNumber); optsControl.CriterionOpen=cell(1,2*input.bodiesToExportNumber);
    optsControl.TypeClose=cell(1,2*input.bodiesToExportNumber); optsControl.CriterionClose=cell(1,2*input.bodiesToExportNumber); optsControl.TrueClose=cell(1,2*input.bodiesToExportNumber);
    optsControl.Update=cell(1,2*input.bodiesToExportNumber); optsControl.Format='Horizontal';
    for bodyNum=1:input.bodiesToExportNumber
        % #.#. Title
        optsControl.TypeOpen{2*bodyNum-1}={'Contains' 'Shift'};
        optsControl.CriterionOpen{2*bodyNum-1}={{'BODY' '%%%' input.bodiesToExport{bodyNum}} -1};
        optsControl.TypeClose{2*bodyNum-1}={'Empty' 'Empty' 'Numeric' 'Shift'};
        optsControl.CriterionClose{2*bodyNum-1}={'' '' '' -1};
        optsControl.TrueClose{2*bodyNum-1}={1 0 1 1};
        % #.#. Number
        optsControl.TypeOpen{2*bodyNum}={'Numeric'};
        optsControl.CriterionOpen{2*bodyNum}={''};
        optsControl.TypeClose{2*bodyNum}={'Contains' 'Shift'};
        optsControl.CriterionClose{2*bodyNum}={'%%%' -1};
        optsControl.TrueClose{2*bodyNum}={1 1};
        optsControl.Update{2*bodyNum-1}={{'Assign' 2 3 num2str(input.bodyBefore+bodyNum)}};
        optsControl.Update{2*bodyNum}={{'Assign' 1 1 num2str(input.bodyBefore+bodyNum)}};
    end
    optsControl.Save='off';
    optsDyn=optsControl;
    % #.#. STATIC DATA
    optsData=struct();
    optsData.TypeOpen=cell(1,4*input.bodiesToExportNumber); optsData.CriterionOpen=cell(1,4*input.bodiesToExportNumber);
    optsData.TypeClose=cell(1,4*input.bodiesToExportNumber); optsData.CriterionClose=cell(1,4*input.bodiesToExportNumber); optsData.TrueClose=cell(1,4*input.bodiesToExportNumber);
    optsData.Update=cell(1,4*input.bodiesToExportNumber); optsData.Format='Horizontal';
    for bodyNum=1:input.bodiesToExportNumber
        % #.#. Title
        optsData.TypeOpen{4*bodyNum-3}={'Contains' 'Shift'};
        optsData.CriterionOpen{4*bodyNum-3}={{'BODY' '%%%' input.bodiesToExport{bodyNum}} -1};
        optsData.TypeClose{4*bodyNum-3}={'Empty' 'Empty' 'Numeric' 'Shift'};
        optsData.CriterionClose{4*bodyNum-3}={'' '' '' -1};
        optsData.TrueClose{4*bodyNum-3}={1 0 1 1};
        % #.#. Number
        optsData.TypeOpen{4*bodyNum-2}={'Shift'};
        optsData.CriterionOpen{4*bodyNum-2}={1};
        optsData.TypeClose{4*bodyNum-2}={'Contains' 'Empty' 'Empty' 'Shift'};
        optsData.CriterionClose{4*bodyNum-2}={'NODES' '' '' -1};
        optsData.TrueClose{4*bodyNum-2}={1 1 0 1};
        optsData.Update{4*bodyNum-3}={{'Assign' 2 3 num2str(input.bodyBefore+bodyNum)}};
        optsData.Update{4*bodyNum-2}={{'Assign' 1 1 num2str(input.bodyBefore+bodyNum)}};
        % #.#. Nodes
        optsData.TypeOpen{4*bodyNum-1}={'Shift'};
        optsData.CriterionOpen{4*bodyNum-1}={1};
        optsData.TypeClose{4*bodyNum-1}={'Empty' 'Shift'};
        optsData.CriterionClose{4*bodyNum-1}={'' -1};
        if input.xShift~=0 || input.yShift~=0
            optsData.Update{4*bodyNum-1}={{'Assign' 'all' 2 input.xShift} {'Assign' 'all' 3 input.yShift}};
        end
        % #.#. Remain
        optsData.TypeOpen{4*bodyNum}={'Shift'};
        optsData.CriterionOpen{4*bodyNum}={1};
        optsData.TypeClose{4*bodyNum}={'Contains' 'Shift'};
        optsData.CriterionClose{4*bodyNum}={'%%%' -1};
    end
    optsData.Save='off';

elseif strcmp(input.mode,'Delete')

    % #.#. STATIC CONTOL + DYNAMIC + STATIC DATA
    optsControl=struct();
    optsControl.TypeOpen=cell(1,input.bodiesToExportNumber); optsControl.CriterionOpen=cell(1,input.bodiesToExportNumber);
    optsControl.TypeClose=cell(1,input.bodiesToExportNumber); optsControl.CriterionClose=cell(1,input.bodiesToExportNumber);
    optsControl.Update=cell(1,input.bodiesToExportNumber); optsControl.Format='Horizontal';
    for bodyNum=1:input.bodiesToExportNumber
        optsControl.TypeOpen{bodyNum}={'Contains' 'Shift'};
        optsControl.CriterionOpen{bodyNum}={{'BODY' '%%%' input.bodiesToExport{bodyNum}} -1};
        optsControl.TypeClose{bodyNum}={'Contains' 'Contains' 'Contains' 'Shift'};
        optsControl.CriterionClose{bodyNum}={'%%%' '%%%' '%%%' -1};
        optsControl.Update{bodyNum}={{'delete'}};
    end
    optsDyn=optsControl;
    optsData=optsControl;

end

% #. Static_Control (reading)
%             tStart=tic; % Duration guess is not not very good because the computing speed is not linear at the beggining and the convergence occurs when STATIC_DATA is already being read (Duration is driven by it)
msg=waitbar(0,'[1/2] Pre-processing 1/3','Name','Progress');
sectionsNew=TextEditor(pathControlExport,optsControl); controlToImport=[sectionsNew{:}]';

% #. Dynamic (reading)
if ishandle(msg)
    waitbar(1/6,msg,'[1/2] Pre-processing 2/3');
end
sectionsNew=TextEditor(pathDynExport,optsDyn); dynToImport=[sectionsNew{:}]';

% #. Static_Data (reading)
if ishandle(msg)
    waitbar(2/6,msg,'[1/2] Pre-processing 3/3');
end
sectionsNew=TextEditor(pathDataExport,optsData); dataToImport=[sectionsNew{:}]';

% #. Options pour l'importation

if strcmp(input.mode,'Import')

    % #.#. Initialisation
    optsControl=struct();
    optsControl.TypeOpen=cell(1,4); optsControl.CriterionOpen=cell(1,4); optsControl.TrueOpen=cell(1,4);
    optsControl.TypeClose=cell(1,4); optsControl.CriterionClose=cell(1,4);
    optsControl.PeriodOpen=cell(1,4); optsControl.Update=cell(1,4);
    % #.#. NUMBER_BODIES
    optsControl.TypeOpen{1}={'Contains' 'Shift'};
    optsControl.CriterionOpen{1}={'NUMBER_BODIES' 1};
    optsControl.PeriodOpen{1}={1 1};
    optsControl.TypeClose{1}={'Shift'};
    optsControl.CriterionClose{1}={0};
    optsControl.Update{1}={{'Assign' input.bodiesToExportNumber}};
    % #.#. BODIES TO ADD
    if strcmpi(input.assignInput,'addBefore')
        optsControl.TypeOpen{end-2}={'Contains' 'Shift'};
        optsControl.CriterionOpen{end-2}={{'BODY' '%%%' num2str(input.bodyBefore+1)} -1};
        optsControl.PeriodOpen{end-2}={1 1};
        optsControl.TypeClose{end-2}={'Shift'};
        optsControl.CriterionClose{end-2}={0};
        optsControl.Update{end-2}={{'addBefore' controlToImport}};
    elseif strcmpi(input.assignInput,'addAfter')
        optsControl.TypeOpen{end-2}={'Contains' 'Contains' 'Contains' 'Shift'};
        optsControl.CriterionOpen{end-2}={{'BODY' '%%%' num2str(input.bodyBefore)} '%%%' '%%%' -1};
        optsControl.PeriodOpen{end-2}={1 1 1 1};
        optsControl.TypeClose{end-2}={'Shift'};
        optsControl.CriterionClose{end-2}={0};
        optsControl.Update{end-2}={{'addAfter' controlToImport}};
    end
    % #.#. Title
    optsControl.TypeOpen{end-1}={'Contains'};
    optsControl.CriterionOpen{end-1}={{'BODY' '%%%'}};
    optsControl.PeriodOpen{end-1}={inf};
    optsControl.TypeClose{end-1}={'Shift'};
    optsControl.CriterionClose{end-1}={0};
    optsControl.Update{end-1}={{'Assign' 1 3 input.bodiesToExportNumber}};
    % #.#. Body number
    optsControl.TypeOpen{end}={'Empty' 'Empty' 'Numeric'};
    optsControl.CriterionOpen{end}={'' '' ''};
    optsControl.PeriodOpen{end}={inf inf inf};
    optsControl.TrueOpen{end}={1 0 1};
    optsControl.TypeClose{end}={'Shift'};
    optsControl.CriterionClose{end}={0};
    optsControl.Update{end}={{'Assign' 1 1 input.bodiesToExportNumber}};
    %% #.#. Dyn
    optsDyn=optsControl;
    optsDyn.TypeOpen(1)=[]; optsDyn.CriterionOpen(1)=[]; optsDyn.PeriodOpen(1)=[];  optsDyn.TrueOpen(1)=[]; optsDyn.TypeClose(1)=[]; optsDyn.CriterionClose(1)=[]; optsDyn.Update(1)=[]; % No 'NUMBER_BODIES'
    optsDyn.Update{1}{1}{2}=dynToImport;
    % #.#. STATIC DATA
    optsData=optsControl; optsData.Update{2}{1}{2}=dataToImport;

elseif strcmp(input.mode,'Delete')

    % #.#. Initialisation
    bodyNumber=input.bodyNumberImport-input.bodiesToExportNumber;
    optsControl=struct();
    optsControl.TypeOpen=cell(1,2*bodyNumber+1); optsControl.CriterionOpen=cell(1,2*bodyNumber+1); optsControl.TrueOpen=cell(1,2*bodyNumber+1);
    optsControl.TypeClose=cell(1,2*bodyNumber+1); optsControl.CriterionClose=cell(1,2*bodyNumber+1);
    optsControl.Update=cell(1,2*bodyNumber+1);
    % #.#. NUMBER_BODIES
    optsControl.TypeOpen{1}={'Contains' 'Shift'};
    optsControl.CriterionOpen{1}={'NUMBER_BODIES' 1};
    optsControl.TypeClose{1}={'Shift'};
    optsControl.CriterionClose{1}={0};
    optsControl.Update{1}={{'Assign' 1 1 num2str(bodyNumber)}};
    k=1;
    for bodyNum=0:bodyNumber-1
        % #.#. Title
        k=k+1;
        optsControl.TypeOpen{k}={'Contains'};
        optsControl.CriterionOpen{k}={{'BODY' '%%%'}};
        optsControl.TypeClose{k}={'Shift'};
        optsControl.CriterionClose{k}={0};
        optsControl.Update{k}={{'Assign' 1 3 num2str(bodyNum)}};
        % #.#. Body number
        k=k+1;
        optsControl.TypeOpen{k}={'Empty' 'Empty' 'Numeric'};
        optsControl.CriterionOpen{k}={'' '' ''};
        optsControl.TrueOpen{k}={1 0 1};
        optsControl.TypeClose{k}={'Shift'};
        optsControl.CriterionClose{k}={0};
        optsControl.Update{k}={{'Assign' 1 1 num2str(bodyNum)}};
    end
    optsDyn=optsControl; optsDyn.TypeOpen(1)=[]; optsDyn.CriterionOpen(1)=[];  optsDyn.TrueOpen(1)=[]; optsDyn.TypeClose(1)=[]; optsDyn.CriterionClose(1)=[]; optsDyn.Update(1)=[]; % No 'NUMBER_BODIES'
    optsData=optsControl;
end

% #. Static_Control (importing)
% #.#. BODIES
if ishandle(msg)
    waitbar(3/6,msg,'[2/2] Updating 1/3');
end
TextEditor(pathControlImport,optsControl);

% #. Dynamic (importing)
if ishandle(msg)
    waitbar(4/6,msg,'[2/2] Updating 2/3');
end
TextEditor(pathDynImport,optsDyn);

% #. Static_Data (importing)
if ishandle(msg)
    waitbar(5/6,msg,'[2/2] Updating 3/3');
end
TextEditor(pathDataImport,optsData);

% #. Close
if ishandle(msg)
    waitbar(6/6,msg,'[2/2] Updating 3/3');
    delete(msg);
end
msgbox('Loading is complete (remember to update the body numbers in the spies section if necessary).','Success','help');
end